const PDFDocument = require('pdfkit');
const { supabase } = require('../config/database');
const logger = require('../utils/logger');

async function exportToPDF(binder) {
    return new Promise(async (resolve, reject) => {
        try {
            const doc = new PDFDocument({
                size: 'A4',
                margin: 50
            });
            
            const chunks = [];
            
            doc.on('data', chunk => chunks.push(chunk));
            doc.on('end', () => resolve(Buffer.concat(chunks)));
            doc.on('error', reject);
            
            // Title
            doc.fontSize(24).font('Helvetica-Bold').text(binder.name, { align: 'center' });
            doc.moveDown(0.5);
            
            // Metadata
            doc.fontSize(10).font('Helvetica').text(`Created: ${new Date(binder.created_at).toLocaleDateString()}`, { align: 'center' });
            if (binder.description) {
                doc.fontSize(9).text(binder.description, { align: 'center' });
            }
            
            doc.moveDown(1);
            doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
            doc.moveDown();
            
            // Content from chats
            if (binder.binder_chats && binder.binder_chats.length > 0) {
                doc.fontSize(14).font('Helvetica-Bold').text('Conversations', { underline: true });
                doc.moveDown();
                
                for (let idx = 0; idx < binder.binder_chats.length; idx++) {
                    const bc = binder.binder_chats[idx];
                    const chat = bc.chats;
                    
                    if (chat) {
                        doc.fontSize(12).font('Helvetica-Bold').text(`${idx + 1}. ${chat.title}`);
                        doc.fontSize(9).font('Helvetica').text(`Source: ${chat.source} | Date: ${new Date(chat.created_at).toLocaleDateString()}`);
                        doc.moveDown(0.3);
                        
                        // Add chunks content
                        if (chat.chunks && chat.chunks.length > 0) {
                            doc.fontSize(9).font('Helvetica');
                            chat.chunks.forEach(chunk => {
                                doc.text(chunk.content, { width: 450 });
                            });
                        }
                        
                        doc.moveDown();
                        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
                        doc.moveDown();
                    }
                }
            }
            
            // Footer
            doc.fontSize(8).text('Generated by ChatBinder', { align: 'center', color: '#999' });
            
            doc.end();
            
        } catch (error) {
            logger.error(`Error creating PDF: ${error.message}`);
            reject(error);
        }
    });
}

async function exportToMarkdown(binder) {
    try {
        let markdown = `# ${binder.name}\n\n`;
        
        if (binder.description) {
            markdown += `${binder.description}\n\n`;
        }
        
        markdown += `**Created:** ${new Date(binder.created_at).toLocaleDateString()}\n\n`;
        markdown += `---\n\n`;
        
        if (binder.binder_chats && binder.binder_chats.length > 0) {
            markdown += `## Conversations\n\n`;
            
            for (let idx = 0; idx < binder.binder_chats.length; idx++) {
                const bc = binder.binder_chats[idx];
                const chat = bc.chats;
                
                if (chat) {
                    markdown += `### ${idx + 1}. ${chat.title}\n\n`;
                    markdown += `- **Source:** ${chat.source}\n`;
                    markdown += `- **Date:** ${new Date(chat.created_at).toLocaleDateString()}\n`;
                    if (chat.url) {
                        markdown += `- **URL:** ${chat.url}\n`;
                    }
                    markdown += `- **Messages:** ${chat.message_count}\n\n`;
                    
                    // Add chunks content
                    if (chat.chunks && chat.chunks.length > 0) {
                        markdown += `#### Content\n\n`;
                        chat.chunks.forEach(chunk => {
                            markdown += chunk.content + '\n\n';
                        });
                    }
                    
                    markdown += `---\n\n`;
                }
            }
        }
        
        return markdown;
    } catch (error) {
        logger.error(`Error creating markdown: ${error.message}`);
        throw error;
    }
}

module.exports = {
    exportToPDF,
    exportToMarkdown
};